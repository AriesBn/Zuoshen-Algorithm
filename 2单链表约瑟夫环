先加后见 保持真我

编号和报数的关系 s编号 m报数 i指的是有几个人玩游戏
	s=（m-1）%i+1	--被杀的节点编号
新编号和旧编号的关系 旧是多 新是少 s指的是原来编号中的第几个
	旧=（新+s-1）%i+1	
总：旧=（新+(m-1)%i+1-1）%i+1
	旧=（新+(m-1)%i）%i+1
	旧=（新+m-1)%i+1
1、首先要遍历 设置一个跟随值跟随头节点向下走 得到玩游戏的人
int temp=1;
Node cur=head.next;
在下一个节点不为空的时候循环
2、使用黑盒子 temp的复用
	temp=getLive(temp,m);
3、得到具体死的是哪个节点 
	当temp减为1的时候回到   
	while(--temp!=0){
		head=head.next;
	}
	head正好到达死亡节点
4、返回之前做好内部结构
	head.next=head;
	return head
public static Node josephusKill(Node head,int m){
	if(head==null||head.next==head||m<1){
		return head;
	}
	int temp=1;
	Node cur=head.next;
	while(cur!=null){
		temp++;
		cur=cur.next;
	}
	temp=getLive(temp,m);
	while(--temp!=0){
		head=head.next;
	}
}
	
public static int getLive(int i,int m){
	if(i==1){
		return 1; 只有一个人玩
	}
	return (getLive(i-1,m)+m-1)%i+1;
}